# 호이스팅

> var로 정의된 변수나 함수선언문, 함수표현식이 유효범위의 최상단으로 끌어올려지는 것처럼 보여지는 현상

JS 엔진은 스크립트를 가져 오면 코드에서 데이터를 위한 메모리를 설정한다. (코드 실행의 준비단계)

함수와 변수가 메모리에 저장되는 방식은 다르다.

- 함수는 전체 함수에 대한 참조와 함께 저장된다.
- 변수의 경우 let과 const(ES6문법)는 초기화 되지 않은 채로 저장이 되고, var는 undefined로 저장이 된다.

#### 변수의 경우

**변수 선언단계**

1. 선언단계 : 변수를 실행컨텍스트의 변수객체에 등록한다
2. 초기화 단계 : 실행 컨텍스트에 등록 된 변수객체에 대한 메모리를 할당한다. 이때, 변수는 undefined로 초기화 된다.
3. 할당단계 : 초기화 된 변수에 값을 할당한다.

이때, var로 선언된 변수는 선언과 초기화가 동시에 진행된다. 하지만 const와 let은 선언된 위치에 와야 초기화 단계가 진행된다. 따라서 선언 이전에 호출하면 ReferenceErr가 발생한다.

let,const모두 호이스팅에 의해, 코드 실행 전 변수가 실행 컨텍스트의 변수 객체에 등록되게 된다. 하지만 let과 const는 선언된 위치에 도달했을때, 초기화(메모리할당)이 이뤄진다.

즉, 선언단계는 var, let, const모두 수행되지만, 초기화는 var만 먼저 수행된다.

let과 const는 선언된 블록에 들어왔을 때 호이스팅에 의한 선언단계가 이뤄지고 TDZ(temporal Dead Zone)가 생성되지만, 변수가 실제 있는 위치에 도달할 때까지 액세스할 수 없다.

**TDZ**

let과 const의 경우 선언 이후 별도로 초기화 단계를 거치게 된다. 이 사이의 간격을 TDZ라고 하며 이 시점에 각각에 접근할 경우 reference err를 발생시킨다.

#### 함수의 경우

함수 선언식은 호이스팅에 영향을 받지만, 함수 표현식은 호이스팅에 영향을 받지 않는다.

**함수 선언식**

```js
function func(){
    console.log("~~~")
}
a();
```

**함수 표현식**

```js
var a = function(){
    console.log("~~~")
}
```

